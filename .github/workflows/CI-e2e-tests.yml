name: zkVerify E2E Tests

on:
  schedule:
    - cron: '0 18 * * *'
  workflow_dispatch:
  pull_request:

jobs:
  e2e-build-and-test:
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: e2e-tests

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'

      - name: Pull Docker image for zkVerify
        run: docker pull horizenlabs/zkverify:latest

      - name: Run setup script (git clone latest zkVerify & attestation-bot repos)
        env:
          GH_TOKEN: ${{ secrets.GH_TOKEN }}
        run: ./setup.sh --fetch-latest

      - name: Install npm dependencies
        run: npm install

      - name: Set up Docker containers
        run: |
          docker-compose down -v
          docker-compose build --no-cache
          docker-compose up -d

      - name: Wait for Ethereum contract to be deployed
        run: |
          MAX_WAIT_TIME=300
          wait_time=0
          while true; do
            if docker-compose exec -T anvil-node test -f /data/contract_data.txt; then
              CONTRACT_ADDRESS=$(docker-compose exec -T anvil-node sh -c "sed -n '1p' /data/contract_data.txt | cut -d ' ' -f 3")
              if [ ! -z "$CONTRACT_ADDRESS" ]; then
                echo "Contract data is ready."
                echo "NH_CONTRACT=$CONTRACT_ADDRESS" >> $GITHUB_ENV
                break
              fi
            fi
            if [ "$wait_time" -ge "$MAX_WAIT_TIME" ]; then
              echo "Timeout reached: contract data file is not ready."
              exit 1
            fi
            echo "Waiting for contract data file to be ready..."
            sleep 3
            wait_time=$((wait_time + 3))
          done

      - name: Run E2E tests
        id: run_tests
        run: |
          mkdir -p reports
          WEBSOCKET=ws://127.0.0.1:9944 NH_CONTRACT=${{ env.NH_CONTRACT }} npm run test 2>&1 | tee reports/test_output.txt

      - name: Parse Test Results
        run: |
          TEST_OUTPUT=$(cat reports/test_output.txt)
          
          PASSED=$(echo "$TEST_OUTPUT" | grep -oP 'Tests:\s+\K\d+(?=\s+passed)')
          FAILED=$(echo "$TEST_OUTPUT" | grep -oP 'Tests:\s+\d+\s+passed,\s+\K\d+(?=\s+failed)')
          SKIPPED=$(echo "$TEST_OUTPUT" | grep -oP 'Tests:\s+\d+\s+passed,\s+\d+\s+failed,\s+\K\d+(?=\s+skipped)')
          TOTAL=$(echo "$TEST_OUTPUT" | grep -oP 'Tests:\s+\K\d+(?=\s+total)')
          
          PASSED=${PASSED:-0}
          FAILED=${FAILED:-0}
          SKIPPED=${SKIPPED:-0}
          TOTAL=${TOTAL:-0}

          echo "PASSED=$PASSED" >> $GITHUB_ENV
          echo "FAILED=$FAILED" >> $GITHUB_ENV
          echo "SKIPPED=$SKIPPED" >> $GITHUB_ENV
          echo "TOTAL=$TOTAL" >> $GITHUB_ENV

          if [ "$FAILED" -eq 0 ]; then
            OVERALL_STATUS="success"
            OVERALL_STATUS_EMOJI=":large_green_circle:"
          else
            OVERALL_STATUS="failure"
            OVERALL_STATUS_EMOJI=":red_circle:"
          fi

          echo "OVERALL_STATUS=$OVERALL_STATUS" >> $GITHUB_ENV
          echo "OVERALL_STATUS_EMOJI=$OVERALL_STATUS_EMOJI" >> $GITHUB_ENV

          if [ "$OVERALL_STATUS" == "failure" ]; then
            exit 1
          fi

      - name: Send Slack Notification
        if: always()
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "${{ env.OVERALL_STATUS_EMOJI }} *zkVerify E2E (Local) TEST STATUS:* ${{ env.OVERALL_STATUS }} ${{ env.OVERALL_STATUS_EMOJI }}\n*Test Results:*\n*Passed:* ${{ env.PASSED }}\n*Failed:* ${{ env.FAILED }}\n*Skipped:* ${{ env.SKIPPED }}\n*Total:* ${{ env.TOTAL }}\n\n*Build URL:* <https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}|Click here to view the build>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.QA_SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
